# -*- coding: utf-8 -*-
"""TPintegrador-Progamacion-1.ipynb

Por Olima Nicolás y Pannunzio Nicolás

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14bC_HOpy4stnVOQTcbsTSNqCDCnPlbzz
"""

import random # Importamos random para obtener números pseudo-aleatorios
import time # Usaremos la librería time para tomar el tiempo de las búsquedas y ordenamientos

try:
    from faker import Faker
except ImportError:
    print("La librería Faker no está instalada. Se intentará instalar...")
    import subprocess
    import sys
    subprocess.check_call([sys.executable, "-m", "pip", "install", "faker"])
    from faker import Faker

# Instanciamos la clase Faker y como argumento
# dos localizaciones: 'es_ES' (español de España)
# y 'en_US'. Para obtener palabras en español y en inglés
fake = Faker(['es_ES', 'en_US'])

# Diccionario con categoriás como claves y listas de productos como valores
categorias_productos = {
    "Electrónica": ["Smartphone", "Laptop", "Auriculares", "Smartwatch", "Tablet"],
    "Ropa": ["Camiseta", "Pantalón", "Zapatillas", "Vestido", "Chaqueta"],
    "Hogar": ["Sartén antiadherente", "Juego de cubiertos", "Almohada memory foam", "Lámpara LED"],
    "Deportes": ["Balón de fútbol", "Raqueta de tenis", "Mancuernas", "Bicicleta"],
    "Juguetes": ["Lego", "Peluche", "Puzzle", "Figura de acción"],
    "Libros": ["Novela bestseller", "Libro de cocina", "Guía de viaje", "Ciencia ficción"],
    "Belleza": ["Crema facial", "Labial mate", "Paleta de sombras", "Perfume"],
    "Alimentación": ["Café gourmet", "Chocolate orgánico", "Snacks proteicos"],
    "Muebles": ["Silla ergonómica", "Mesa de centro", "Sofá cama"],
    "Jardín": ["Maceta de cerámica", "Cortacésped", "Manguera extensible"]
}

"///////////////////////////////////////FUNCIONES///////////////////////////////////////"
# Esta función recibe como parámetro el tamaño de la lista a generar
# y retorna una lista de productos(diccionarios)
def generar_lista(tamanio):
    nombres_usados = set() # Usamos un set para ir almacenando los nombres de productos y asegurarnos que no se repitan
    lista_productos=[] #Usaremos esta lista para almacenar los productos (diccionarios)

    for _ in range(tamanio):
        categoria = random.choice(list(categorias_productos.keys())) # Elegimos al azar una categoria desde las claves de nuestro diccionario predefinido
        producto_base = random.choice(categorias_productos[categoria]) # Elegimos desde esa categoría (lista) un producto

        # Crear nombre único
        while True:
            # Para crear un nombre, metemos en una string el producto base y
            # una marca ficticia generada por fake.word() que pasamos a mayúsculas
            # y le agregamos un número entero random, que representaría el modelo
            nombre = f"{producto_base} {fake.word().capitalize()}-{random.randint(1, 9999)}"
            if nombre not in nombres_usados: # Verificamos que el nombre generado no exista en el set
                nombres_usados.add(nombre) # Si no existe, lo agregamos al set
                break

        # Este diccionario es nuestra plantilla para crear productos
        producto = {
            "nombre": nombre,
            "precio": round(random.uniform(5000.0, 99999.9), 2), # Para el precio obtiene un número flotante entre 5000.0 y 99999.9
            "stock": random.randint(0, 1000), # Para el stock obtiene un entero pseudoaleatorio entre 0 y 1000
            "categoria": categoria
        }

        lista_productos.append(producto) # Guardamos el producto(diccionaro) en la lista
    return lista_productos # Al finalizar retornamos la lista de productos

# Función que recorre la lista de productos y la muestra.
def mostrar_productos(lista): # Recibe como argumento una lista
    for producto in lista:
        print(f"Nombre: {producto['nombre']} || Precio: $ {producto['precio']} || Stock: {producto['stock']} || Categoría: {producto['categoria']}")

########## FUNCIONES DE BÚSQUEDA ##########

# Búsqueda lineal #
def busqueda_lineal(lista, clave, objetivo):
    imprimir=False
    posicion=0
    if clave=='precio':
        objetivo=float(objetivo)
    elif clave=='stock':
        objetivo=int(objetivo)
    for producto in lista: # Recorre la lista pasada como argumento
        if producto[clave] == objetivo: # Compara el valor actual con el objetivo que le brindamos como argumento
            imprimir=True
            break
        posicion+=1
    if imprimir:
        print(f"Producto encontrado en la posición {posicion}")
        print(f"Nombre: {producto['nombre']} || Precio: ${producto['precio']} || Stock: {producto['stock']} || Categoría: {producto['categoria']}")
    else:
        print(f"El producto {objetivo} no se encontró. Escriba el nombre exacto.")

# Búsqueda binaria #

def busqueda_binaria_diccionarios(lista, clave, objetivo):
    if clave=='precio':
        objetivo=float(objetivo)
        print(f"Convertido a float: {objetivo}")
    elif clave=='stock':
        objetivo=int(objetivo)
        print(f"Convertido a int: {objetivo}")
    imprimir=False
    izquierda, derecha = 0, len(lista) - 1
    while izquierda <= derecha:
        medio = (izquierda + derecha) // 2
        valor = lista[medio][clave]
        if valor == objetivo:
            imprimir=True
            break
        elif valor < objetivo:
            izquierda = medio + 1
        else:
            derecha = medio - 1
    if imprimir:
        print(f"Producto encontrado en la posición {medio}")
        print(f"Nombre: {lista[medio]['nombre']} || Precio: ${lista[medio]['precio']} || Stock: {lista[medio]['stock']} || Categoría: {lista[medio]['categoria']}")
    else:
        print("Producto no encontrado.")


########## FUNCIONES DE ORDENAMIENTO ##########

# Función ordenamiento burbuja
def bubble_sort_diccionarios(lista, clave, mayoramenor=False):
    n = len(lista)

    for i in range(n):
        for j in range(0, n - i - 1):
            if mayoramenor:
                if lista[j][clave] < lista[j + 1][clave]:
                    lista[j], lista[j + 1] = lista[j + 1], lista[j]
            else:
                if lista[j][clave] > lista[j + 1][clave]:
                    lista[j], lista[j + 1] = lista[j + 1], lista[j]

    return lista

# Función ordenamiento rápido
def quick_sort_diccionarios(lista, clave, mayoramenor=False):
    if len(lista) <= 1:
        return lista
    else:
        pivote = lista[0]
        if mayoramenor:
            menores = [x for x in lista[1:] if x[clave] <= pivote[clave]]
            mayores = [x for x in lista[1:] if x[clave] > pivote[clave]]
            return quick_sort_diccionarios(mayores, clave) + [pivote] + quick_sort_diccionarios(menores, clave)
        else:
            menores = [x for x in lista[1:] if x[clave] <= pivote[clave]]
            mayores = [x for x in lista[1:] if x[clave] > pivote[clave]]
            return quick_sort_diccionarios(menores, clave) + [pivote] + quick_sort_diccionarios(mayores, clave)


"///////////////////////// GENERAMOS LAS LISTAS /////////////////////////"

lista_grande = generar_lista(10000) # Generamos una lista más grande que se guarda en lista_grande
print(f"Se generaron {len(lista_grande)} productos únicos.")

lista_chica = lista_grande[0:100] # Generamos una lista chica a partir de los primeros 100 elementos de la lista grande
print(f"Se copiaron los primeros {len(lista_chica)} productos de la lista chica.")



"/////////////////////////////// ORDENAMIENTO ///////////////////////////////"


########## QuickSort ##########

# Ordenamiento rápido (QuickSort) lista_chica


rapido_inicio=time.perf_counter()
lista_chica_ordenada_rapido = quick_sort_diccionarios(lista_chica,"nombre")
rapido_fin=time.perf_counter()

tiempo_rapido_lista_chica=rapido_fin-rapido_inicio

# Ordenamiento rápido (QuickSort) lista_grande
rapido_inicio=time.perf_counter()
lista_grande_ordenada_rapido = quick_sort_diccionarios(lista_grande,"nombre")
rapido_fin=time.perf_counter()

tiempo_rapido_lista_grande=rapido_fin-rapido_inicio



########## BubbleSort ##########

# Ordenamiento burbuja lista chica

burbuja_inicio=time.perf_counter()
lista_chica_ordenada_burbuja = bubble_sort_diccionarios(lista_chica,"nombre")
burbuja_fin=time.perf_counter()

tiempo_burbuja_lista_chica=burbuja_fin-burbuja_inicio


# Ordenamiento burbuja lista grande

burbuja_inicio=time.perf_counter()
lista_grande_ordenada_burbuja = bubble_sort_diccionarios(lista_grande,"nombre")
burbuja_fin=time.perf_counter()

tiempo_burbuja_lista_grande=burbuja_fin-burbuja_inicio

"////////////////////////////// TIEMPOS DE ORDENAMIENTO ////////////////////////////////"
print("////////////////////////////// TIEMPOS DE ORDENAMIENTO ////////////////////////////////\n")
print(f"Tiempo QUICK_SORT lista CHICA para {len(lista_chica)} elementos: {tiempo_rapido_lista_chica:.8f}")
print(f"Tiempo BUBBLE_SORT lista CHICA para {len(lista_chica)} elementos: {tiempo_burbuja_lista_chica:.8f}")

print("\n")

print(f"Tiempo QUICK_SORT lista GRANDE para {len(lista_grande)} elementos: {tiempo_rapido_lista_grande:.8f}")
print(f"Tiempo BUBBLE_SORT lista GRANDE para {len(lista_grande)} elementos: {tiempo_burbuja_lista_grande:.8f}")
print("\n")

print("A continuación se mostrará la lista chica.")
input("Presione una tecla...")

"//////////////////////// PARÁMETROS DE BÚSQUEDA ////////////////////////"
print("")
mostrar_productos(lista_chica)

print("")
campo='nombre'
buscar=input("Ingrese el nombre del producto: ") # Buscar visualmente un valor en la lista de productos y copiarlo aquí


"////////////////////////////// BÚSQUEDA ////////////////////////////////"

### Busqueda LINEAL lista chica
print("\nBusqueda LINEAL lista chica\n")
lineal_inicio=time.perf_counter()
busqueda_lineal(lista_chica, campo, buscar)
lineal_fin=time.perf_counter()
tiempo_lineal_lista_chica = lineal_fin-lineal_inicio

### Busqueda LINEAL lista grande
print("\n\nBusqueda LINEAL lista grande\n")
lineal_inicio=time.perf_counter()
busqueda_lineal(lista_grande, campo, buscar)
lineal_fin=time.perf_counter()
tiempo_lineal_lista_grande=lineal_fin-lineal_inicio


### Busqueda binaria lista chica

print("\n\nBusqueda binaria lista chica\n")
binaria_inicio=time.perf_counter()
busqueda_binaria_diccionarios(lista_chica_ordenada_rapido, campo, buscar)
binaria_fin=time.perf_counter()
tiempo_binaria_lista_chica=binaria_fin-binaria_inicio

### Busqueda binaria lista grande

print("\n\nBusqueda binaria lista grande\n")
binaria_inicio=time.perf_counter()
busqueda_binaria_diccionarios(lista_grande_ordenada_rapido, campo, buscar)
binaria_fin=time.perf_counter()
tiempo_binaria_lista_grande=binaria_fin-binaria_inicio

"////////////////////////////// TIEMPOS DE BÚSQUEDA ////////////////////////////////"

print("\n\n////////////////////////////// TIEMPOS DE BÚSQUEDA ////////////////////////////////\n")

print(f"Tiempo BÚSQUEDA LINEAL lista CHICA: {tiempo_lineal_lista_chica:.8f}")
print(f"Tiempo BÚSQUEDA BINARIA lista CHICA: {tiempo_binaria_lista_chica:.8f}")
print("")
print(f"Tiempo BÚSQUEDA LINEAL lista GRANDE: {tiempo_lineal_lista_grande:.8f}")
print(f"Tiempo BÚSQUEDA BINARIA lista GRANDE: {tiempo_binaria_lista_grande:.8f}")
